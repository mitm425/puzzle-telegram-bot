```python
import os
import json
import logging
from datetime import datetime, timedelta
from random import choice
from telegram import (
    Update,
    InlineKeyboardButton,
    InlineKeyboardMarkup,
    InputFile
)
from telegram.ext import (
    Application,
    CommandHandler,
    CallbackQueryHandler,
    MessageHandler,
    filters,
    ContextTypes
)

# --- –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è ---
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    level=logging.INFO
)
BOT_TOKEN = os.getenv("BOT_TOKEN")

# --- –ò–≥—Ä–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ ---
LANGUAGES = {
    "ru": {
        "welcome": "–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ Mystery Roles!",
        "level": "–£—Ä–æ–≤–µ–Ω—å {}",
        "hint_button": "üí° –ü–æ–¥—Å–∫–∞–∑–∫–∞ (–æ—Å—Ç–∞–ª–æ—Å—å: {})",
        "block_button": "‚õî –ó–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å –∏–≥—Ä–æ–∫–∞",
        "hint_text": "–ü–æ–¥—Å–∫–∞–∑–∫–∞: {}"
    },
    "en": {
        "welcome": "Welcome to Mystery Roles!",
        "level": "Level {}",
        "hint_button": "üí° Hint (left: {})",
        "block_button": "‚õî Block player",
        "hint_text": "Hint: {}"
    }
}

LEVELS = {
    1: {
        "riddle_ru": "üé≠ –í —Ç–µ–º–Ω–∏—Ü–µ —Å—ã—Ä–æ–π —Ç–µ–º–Ω–æ—Ç—ã,\n–ë–µ–∑ –æ–∫–æ–Ω, –Ω–æ –ø–æ–ª–Ω–∞ –∫—Ä–∞—Å–æ—Ç—ã.",
        "riddle_en": "üé≠ In a dungeon damp and tight,\nNo windows but full of light.",
        "answer": ["–∫–∞—Ä—Ç–∏–Ω–∞", "picture"],
        "hints_ru": ["–ü—Ä–µ–¥–º–µ—Ç –∏—Å–∫—É—Å—Å—Ç–≤–∞", "–í–∏—Å–∏—Ç –Ω–∞ —Å—Ç–µ–Ω–µ"],
        "hints_en": ["Art object", "Hangs on the wall"],
        "image": "level1.jpg"
    }
}

ROLES = {
    "spy": {
        "name_ru": "–®–ø–∏–æ–Ω",
        "name_en": "Spy",
        "ability_ru": "–í–∏–¥–∏—Ç –ø–æ–¥—Å–∫–∞–∑–∫–∏ –¥—Ä—É–≥–∏—Ö –∏–≥—Ä–æ–∫–æ–≤",
        "ability_en": "Can see other players' hints"
    },
    "wizard": {
        "name_ru": "–ö–æ–ª–¥—É–Ω",
        "name_en": "Wizard",
        "ability_ru": "–ú–æ–∂–µ—Ç –∑–∞–º–æ—Ä–æ–∑–∏—Ç—å –∏–≥—Ä–æ–∫–∞ –Ω–∞ 1 —É—Ä–æ–≤–µ–Ω—å",
        "ability_en": "Can freeze another player for 1 level"
    }
}

# --- –•—Ä–∞–Ω–∏–ª–∏—â–µ –¥–∞–Ω–Ω—ã—Ö ---
class GameStorage:
    def __init__(self):
        self.players = {}
        self.games = {}

    def add_player(self, user_id: int, lang: str):
        self.players[user_id] = {
            "lang": lang,
            "role": choice(list(ROLES.keys())),
            "current_level": 1,
            "hints_used": 0,
            "hints_available": 3,
            "blocked_until": None
        }

storage = GameStorage()

# --- –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∫–æ–º–∞–Ω–¥ ---
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    keyboard = [
        [InlineKeyboardButton("üá∑üá∫ –†—É—Å—Å–∫–∏–π", callback_data="lang_ru")],
        [InlineKeyboardButton("üá¨üáß English", callback_data="lang_en")]
    ]
    await update.message.reply_text(
        "–í—ã–±–µ—Ä–∏—Ç–µ —è–∑—ã–∫ / Choose language:",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )

async def handle_lang(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    user_id = query.from_user.id
    lang = query.data.split("_")[1]
    
    storage.add_player(user_id, lang)
    player = storage.players[user_id]
    role_info = ROLES[player["role"]]
    
    await query.edit_message_text(
        f"{LANGUAGES[lang]['welcome']}\n"
        f"–í–∞—à–∞ —Ä–æ–ª—å: {role_info[f'name_{lang}']}\n"
        f"–°–ø–æ—Å–æ–±–Ω–æ—Å—Ç—å: {role_info[f'ability_{lang}']}\n\n"
        f"{LANGUAGES[lang]['level'].format(player['current_level'])}"
    )
    await send_level(update, context, user_id)

async def send_level(update: Update, context: ContextTypes.DEFAULT_TYPE, user_id: int):
    player = storage.players[user_id]
    lang = player["lang"]
    level = LEVELS[player["current_level"]]
    
    keyboard = [
        [InlineKeyboardButton(
            LANGUAGES[lang]["hint_button"].format(player["hints_available"]),
            callback_data="hint"
        )],
        [InlineKeyboardButton(
            LANGUAGES[lang]["block_button"],
            callback_data="block"
        )]
    ]
    
    await context.bot.send_message(
        chat_id=user_id,
        text=f"{level[f'riddle_{lang}']}",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )

async def handle_hint(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    user_id = query.from_user.id
    player = storage.players[user_id]
    
    if player["hints_used"] < player["hints_available"]:
        level = LEVELS[player["current_level"]]
        hint = level[f'hints_{player["lang"]}'][player["hints_used"]]
        player["hints_used"] += 1
        
        await query.answer(LANGUAGES[player["lang"]]["hint_text"].format(hint))
    else:
        await query.answer("No hints left!")

async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.message.from_user.id
    player = storage.players.get(user_id)
    
    if not player:
        await update.message.reply_text("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–∞—á–Ω–∏—Ç–µ –∏–≥—Ä—É —Å /start")
        return
    
    level = LEVELS[player["current_level"]]
    user_answer = update.message.text.lower()
    
    if user_answer in level["answer"]:
        player["current_level"] += 1
        player["hints_used"] = 0
        await update.message.reply_text("‚úÖ –ü—Ä–∞–≤–∏–ª—å–Ω–æ! –°–ª–µ–¥—É—é—â–∏–π —É—Ä–æ–≤–µ–Ω—å:")
        await send_level(update, context, user_id)
    else:
        await update.message.reply_text("‚ùå –ù–µ–≤–µ—Ä–Ω–æ, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑")

# --- –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞ ---
async def main():
    app = Application.builder().token(BOT_TOKEN).build()
    
    app.add_handler(CommandHandler("start", start))
    app.add_handler(CallbackQueryHandler(handle_lang, pattern="^lang_"))
    app.add_handler(CallbackQueryHandler(handle_hint, pattern="^hint$"))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))
    
    await app.run_polling()

if __name__ == "__main__":
    import asyncio
    asyncio.run(main())
```
